# 类与对象

## 类的定义

```C++
class classname;
{
    //成员方法
    //成员变量
};//注意分号
```

## 类的两种定义方法

1.声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理 

```C
class Person
{
public:
    void showinfo()
    {
        cout<<_name<<"-"<<_sex<<"-"<<_age<<endl;
    }
private:
    char* _name;
    char* _sex;
    int _age;
};
```

2.声明放在.h文件中，类的定义放在.cpp文件

## 类的访问限定符及封装

### 访问限定符

限定类中的成员能否直接在类外来使用

public--公有的	prviate--私有的	protect--保护的

- public修饰的成员在类外可以直接被访问 

- protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的) 

- 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止 

- class的默认访问权限为private，struct为public(因为struct要兼容C) 

### 封装 

**面向对象三大特征：封装、继承、多态**

将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口和对象来交互

## 类的作用域

类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用 :: 作用域解析符指明成员属于哪个类域。  

```C++
class Person
{
public:
    void PrintPersonInfo();
private:
    char _name[20];
    char _gender;
    int _age;
};
//这里需要指定PrintPersonInfo是属于Person这个类域
void Person::PrintPersonInfo()
{
    cout<<_name<<_gender<<_age<<endl;
}
```

## 类的实例化

类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它。一个类可以实例化出多个对象，实例化出的对象占用实际的物理空间，存储类成员变量 

## 类的大小

一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比 较特殊，编译器给了空类一个字节来唯一标识这个类。 

- **空类的大小是一个字节**

## this指针

### 1.概念

C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。  

### 2.特性

​	(1) this指针的类型：类类型* const 

​	(2) 只能在“成员函数”的内部使用  

​	(3) this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this 形参。所以对象中不存储this指针。  

​	(4) this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递  

## 类的6个默认成员函数

 如果一个类中什么成员都没有，简称为空类，空类中也会有以下6个默认成员函数

构造-析构-拷贝构造-赋值运算符重载-两个&的重载

## 构造函数

### 1.概念

构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，保证每个数据成员都有一个合适的初始值，并且在对象的生命周期内只调用一次。  

### 2.特性

1.名字必须和类名相同

2.没有返回值类型：返回值类型位置什么都不写

3.编译器自动调用

4.在整个对象的声明周期内只调用一次

5.构造函数可以重载

```C++
class Date
{
public:
    //无参构造函数
    Date()
    {}
    //带参构造函数
    Date(int year,int month,int day)
    {
        _year=year;
        _month=month;
        _day=day;
    }
private:
    int _year;
    int _month;
    int _day;
};
void TestDate()
{
    Date d1;//调用无参构造函数
    Date d2(2021,6,6);//调用带参构造函数  
   	//Date d3()错误，这是一个函数声明，函数名为d3，无参数，返回值为Date类型
}
```

6.如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成 。

7.无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认成员函数。 	

8.构造函数不负责给对象开辟空间，只负责对对象中的成员变量进行初始化

## 析构函数

### 1.概念

 与构造函数功能相反 ，对象在销毁时会自动调用析构函数，完成类的一些资源清理工作 

 类的析构函数调用完全按照构造函数调用的相反顺序进行调用 

### 2.特性

1.析构函数名是在类名前加~

2.不是负责销毁对象本身空间，而是销毁对象中开辟的一些其他空间

3.无参数无返回值 

4.一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。 

5.对象生命周期结束时，C++编译系统系统自动调用析构函数。 

6.先创建的对象后销毁

```C
typedef int DataType;
class SeqList
{
public:
    SeqList(int capacity=10)
    {
    	_pData=(DataType*)malloc(sizeof(DataType)*capacity);
		assert(_pData);
        _capacity=capacity;
        _size=0;
	}
    ~SeqLis()
    {
        if(_pData)
        {
            free(_pData);//释放堆上空间
            _pData=NULL;//将指针置空
            _capacity=0;
            _size=0;
		}
    }
  
private:  
    DataType* _pData;
    size_t _capacity;
    size_t _size;
};
```

## 拷贝构造函数

#### 1.概念

只有单个形参，该形参是对本类类型对象的引用(一般常用const修饰)，在用已存在的类类型对象创建新对象时由编译器自动调用 

- **如果一个类中未涉及到资源(动态开辟内存空间、打开文件)管理时，拷贝函数是否提供都可以；**

  **如果一个类中涉及到资源的管理时，则必须显示定义拷贝构造函数；**

  **否则编译器生成的默认拷贝构造函数会出问题**

#### 2.特性

1.参数只有一个，类型为：**类类型的引用** 

2.常用const修饰

3.若未显示定义，系统生成默认的拷贝构造函数。默认的拷贝构造函数对象按内存存储按字节完成拷贝，

这种拷贝叫做浅拷贝

```C
Data(const Data& b)
{
    _year=b._year;
    _month=b._month;
    _day=b._day;
}
    
```



