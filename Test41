# 文件压缩

文件压缩是指在不丢失有用信息的前提下，缩减数据量以减少存储空间，提高其传输、存储和处理效率，或按照一定的算法对文件中数据进行重新组织，减少数据的冗余和存储的空间的一种技术方法。  

# 为什么需要压缩

1. 紧缩数据存储容量，减少存储空间 
2. 可以提高数据传输的速度，减少带宽占用量，提高通讯效率 
3. 对数据的一种加密保护，增强数据在传输过程中的安全性  

# 压缩方法 

## 1. 专有名词采用固定短语 

 比如：陕西科技大学，简称陕科大，就可以提到压缩的目的，但只能针对于大家所熟知的专有名词。 

## 2. 缩短文件中重复的数据 (LZ777)

 比如文件中存放数据为：mnoabczxyuvwabc123456abczxydefgh 

 对文件中重复数据使用（距离，长度）对进行替换，压缩之后的结果为：

 mnoabczxyuvw(9,3)123456(18, 6)defgh 

## 3. 给文件中每个字节找一个更短的编码 

 比如文件中存放数据为：ABBBCCCCCDDDDDDD 

| 字符 | 静态等长编码 | 动态不登场编码 |
| ---- | ------------ | -------------- |
| A    | 00           | 100            |
| B    | 01           | 101            |
| C    | 10           | 11             |
| D    | 11           | 0              |

采用静态等长编码压缩： 00010101 10101010 10000000 00000000 

采用动态不等长编码压缩：10010110 11011111 11111100 00000000 

# 压缩流程

**1.统计源文件中每个字节出现的次数**

**2.根据统计的结果创建huffman树**

​		1.根据所给的权值创建只有根结点的二叉树森林 

​		2.循环进行以下操作，直到二叉树森林中只剩下一个节点

​				a.从森林中获取根结点权值最小的两棵二叉树

​				b. 以这两棵二叉树为左右子树创建一个新的二叉树

​				c.将新的二叉树放回到二叉树森林中

**3.通过huuffman树获取每个字节的编码**

**4.先将解压缩信息写进压缩文件中再使用获取的字节的编码对源文件进行改写**

# 解压缩

**1.在压缩文件中读取解压缩信息**

​	源文件后缀、总行数以及字符频次信息

**2.根据解压缩信息还原Huffman树**

**3.读取压缩数据，结合Huffman树解压缩**

## 压缩文件格式

解压缩需要信息：

​		源文件的后缀

​		频次信息总行数

​		字节出现频次信息

​		压缩的数据

## 1.huffman树

从二叉树的根结点到二叉树中所有叶结点的路径长度与相应权值的乘积之和为该二叉树的带权路径长度WPL

**将带权路径最小的二叉树称为Huffman树**  

(让权值大的节点离根节点近一点，让权值小的节点离根节点远一些)

## 2.huffman树构建

1.由给定的n个权值{w1,w2,w3,....,wn}构造n棵只有根节点的二叉树森林F={T1,T2,T3,....,Tn},每棵二叉树

​	Ti只有一个带权值wi的根节点，左右孩子均为空。

2.重复以下步骤，直到F中只剩下一棵树为止：

- 在F中选取两棵根节点权值最小的二叉树，作为左右子树构造一棵新的二叉树，新二叉树根结点权值是其左右子树根节点权值之和
- 在F中删除这两棵二叉树
- 把新的二叉树加入到F中

### 3.获取huffman编码

​	1.以字符串中每个字符出现的总次数为权值构建huffman树

​	2.huffman树中左分支用0代替，右分支用1代替

​	3.所有权值节点都在叶子位置，遍历每条到叶子节点的路径获取字符编码 

# 遇到的问题

- **只要解压缩结果不对，最直接的排错方法是：**

  检查压缩和解压缩时的Huffman树是否一样，即只需要对比频次信息是否一样

- **文件中字节种类比较多，而且出现次数比较均匀 ，即Hufffman树越接近平衡二叉树，压缩结果越不理想**

**1.二进制“+”:“W”不定义该运算符或到预定义运算符可接收的类型的转换**

​	只需要在类ByteInfo中operator+重载一下

**2.程序创建的Huffman树种权值为1的节点不是叶子节点**

​	原因是Huffman树中还有权值为0的二叉树，因此需要在创建树的时候剔除掉权值为0的树。

​	即在创建Huffman树的时候多传入一个参数invalid，同时重载operator==和operator！=

**3.一开始读源文件读到的字节个数就是0**

​	原因是上次读操作结束后，文件指针就到了文件结尾处，需要使用fseek(pf，0，SEEK_SET)将指针移	动

​	到起始位置

**4.对源文件改写时最后一个字节没有写进去**

​	原因是最后 一次循环时，bitCount没有到8，因此没有写进去，因此循环结束后，要把剩余的几个字节	

​	也写进去

**5.最后一个字节会多解压缩几个字节**

​	压缩时，最后一个字节的压缩数可能不满8个比特位，因此解压缩时，需要注意压缩够了就停止

**6.处理汉字时，代码会崩溃**

​	汉字对应的是utf-8格式，每个汉字可能用多个字节来表示，而且每个字节都排在ASCLL表之后，因此汉字

​	在数组中对应的下标就成了负数，就会崩溃

​	解决方案：将所有的char换成unsigned char

**7.源文件中有多行时，解压缩结果会出问题**

​	读取解压缩信息时，调用GetLine函数读取一行字符串时，如果读到‘\n’，就会直接break

​	解决方案：增加代码，读取到的如果是“\n”,就继续读取这一行

**8.解压缩的时候只解压缩了一部分**

​	压缩文件是二进制格式文件，从压缩文件中读取时，如果遇到FF即-1时就会认为已经读取到文件末尾。

​	解决方案：将程序中所有打开文件的方式替换成二进制方式的读写

​	
