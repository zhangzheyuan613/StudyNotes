# 哈希

一种高效的用来搜索的数据结构

通过函数去计算在表格中的插入位置——>f(x)=x%capacity

## 缺陷

如果继续往表格中插入元素11

addr=11%10=1

则不能将11插入到表格的1号位置，即如果要插入，必须保证该位置一定没有元素

### 哈希冲途--哈希碰撞

不同的元素，通过相同的哈希函数，计算出了相同的哈希地址

### 解决方案

**检测哈希函数设计是否合理——如果不合理，可能会导致元素集中在某个范围内，使得发生哈希冲途概**

**概率非常高**

​	常见哈希函数：

​			1.关于元素key的一个线性的函数

​			2.除留余数法：设散列表中允许的地址数为m，取一个不大于m，但最接近m的质数p作为除数

​										Hash(key)=key%p(p<=m)

​			3.平方取中法

​			4.折叠法

​			5.随机数法

​			6.数学分析法

- 不论哈希函数设计的有多精妙，都不能完全解决哈希冲突

### 真正解决哈希冲途的方式

#### 1.闭散列

从发生哈希冲突的位置开始找下一个非空的位置：线性探测和二次探测

##### 	线性探测：

​	从发生哈希冲突的位置逐个依次往后查找，如果查找到空间的末尾，也没有发现空位置时，

​	再折回到空间起始位置继续查找，直到找到空位置

- **如何知道一个位置上是否有元素？**

  给每个空间一个标记：EMPTY	EXIST	DELETE

- **删除元素只需要改变状态，但不能改成EMPTY，因为如果改成EMPTY，该位置之前发生冲突的那些元素就找不到了**

- **优点**

  找下一个空位置方式简单

- **线性探测缺陷**

  容易产生数据的堆积——即如果发生冲突，冲突的元素容易连成一片

##### 	二次探测： 

​	从发生哈希冲突的位置按照H(i)=H0+i^2或H(i)=H0-i^2（化简：H(i+1)=H(i)+2*i+1）往后插入

- **优点**

  解决数据堆积问题

- **缺点**

  当表格中空位置比较少的时候，可能需要找很多次

#### 2.开散列

数组+链表的集合——>数组中的每个元素都是链表，每条链表当中挂的都是发生哈希冲突的元素

**1.某些链表比较长，影响哈希性能？**

​	对哈希进行扩容——扩容时机：有效元素的个数与桶的个数相等时

**2.扩容次数越多，哈希桶的个数越多，有时还没达到扩容的时机，发现一些链表已经特别长了**

​	插入时，当发现链表中节点的个数>=8时，可以考虑将链表换成红黑树，来降低哈希的影响

​	删除时，当发现红黑树汇总节点个数<=6时，将红黑树转换为链表

**3.哈希函数改进：除留余数法每次建议模一个素数——每次扩容时尽量找一个具有接近两倍关系的素数——素数	    表——SGI-STL3.0**

**4.哈希函数改进：除留余数法——data%哈希桶容量——>data：要是整形才可以**

​	**data也可能是非整形的——比如：字符串——>给哈希桶的模板参数列表多增加一个参数T2Int——>将来用	户在使用的时候，跟进所存储的元素的类型自己提供对应的转换方式——仿函数**

#### 3.再散列











































